---
title: "stringr——处理字符串"
author: 王诗翔
date: 2018-09-17
slug: "stringr-operation"
categories: 
    - R
tags:
    - stringr
    - 字符串处理
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(collapse = TRUE, dev = "png", comment = "#>")
#Sys.setlocale('LC_ALL','C') # Embed this directly in the Rmarkdown script that contains the Chinese character comment
options(digits=3)
options(max.print=200)
```

导入包：

```{r}
library(tidyverse)
library(stringr)
```

```{r}
x = c("\"", "\\")

```

显示字符串原始内容：

```{r}
writeLines(x)
```

### 字符串长度

```{r}
str_length(c("a", "R for data science", NA))
```

### 字符串组合

组合两个或多个：

```{r}
str_c("x", "y")
str_c("x", "y", "z")
```

控制分隔：

```{r}
str_c("x", "y", sep = ",")
```

缺失值是可以传染的，我们可以将`NA`输出为`"NA"`：

```{r}
x = c("abc", NA)
str_c("|-", x, "-|")
str_c("|-", str_replace_na(x), "-|")
```

组合函数是向量化的：

```{r}
str_c("prefix-", c("a", "b", "c"), "-suffix")
```

将字符向量合并为字符串：

```{r}
str_c(c("x", "y", "z"), collapse = ", ")
```

### 字符串取子集

```{r}
x = c("Apple", "Banana", "Pear")
str_sub(x, 1, 3)
```

负数表示从后到前：

```{r}
str_sub(x, -3, -1)
```

注意如果字符串过短函数也会返回尽可能多的字符：

```{r}
str_sub("a", 1, 5)
```

以赋值的形式修改字符串：

```{r}
str_sub(x, 1, 1) = str_to_lower(str_sub(x, 1, 1))
x
```

### 区域设置

字符串的使用因国家地区不同可能有所不同。

```{r}
str_to_upper(c("i", "l"))
str_to_upper(c("i", "l"), locale = "tr")
```

排序：

```{r}
x = c("apple", "eggplant", "banana")

str_sort(x, locale = "en")

str_sort(x, locale = "haw")
```

## 使用正则表达式

我们可以通过`str_view()`和`str_view_all()`函数学习正则表达式。函数接受一个字符向量和一个正则表达式。

### 基础匹配

精确匹配字符串：

```{r}
x = c("apple", "banana", "pear")
str_view(x, "an")
```

另一个复杂的模式是使用`.`，它可以匹配除换行符外的任意字符：

```{r}
str_view(x, ".a.")
```

### 锚点

* `^`从字符串开头进行匹配
* `$`从字符串末尾进行匹配

```{r}
str_view(x, "^a")
str_view(x, "a$")
```

### 字符串类与字符选项

除了`.`，还有4种常见的字符类：

* `\d`匹配任意数字
* `\s`匹配任意空白符
* `[abc]`匹配a、b或c
* `[^abc]`匹配除a、b、c之外的任意字符

因为要对`\`转义，在R中使用正则需要`\\s`来匹配空白符，其他也一样。

`|`可以获取可选模式，比如`abc|xyz`匹配`abc`或`xyz`，该操作符的优先级很低。

```{r}
str_view(c("grey", "gray"), "gr(e|a)y")
```

### 重复

该操作用来控制某个模式能够匹配多少次：

* `?`- 0次或一次
* `+`- 1次或多次
* `*`- 0次或多次

```{r}
x = "1888 is the longest year in Roman numerals: MDCCCLXXXVIII"

str_view(x, "CC?")

str_view(x ,"CC+")
```


精确匹配次数：

* `{n}`- 匹配n次
* `{n,}`- 匹配n次或更多次
* `{,m}`- 最多匹配m次
* `{n, m}`- 匹配n到m次

```{r}
str_view(x, "C{2}")

str_view(x, "C{2,}")

str_view(x, "C{2,3}")
```

> 默认的匹配方式是贪婪的，正则表达式会匹配尽量长的字符串，在后面添加`?`可以将匹配方式更改为懒惰的，即匹配尽量短的字符串。

```{r}
str_view(x, "C{2,3}?")

str_view(x, "C[LX]+?")
```


### 分组与回溯引用

括号除了可以消除复杂表达式的歧义，还可以定义分组，我们可以通过**回溯引用**（如`\1`,`\2`等）来引用这些分组。

```{r}
str_view(fruit, "(..)\\1", match = TRUE)
```

## 工具

学习stringr多种函数，可以：

* 确定与某种模式相匹配的字符串
* 找出匹配的位置
* 提取出匹配的内容
* 使用新值替换匹配内容
* 基于匹配拆分字符串

### 匹配检测

要想知道一个字符向量能否匹配一种模式，可以使用`str_detect()`：

```{r}
x = c("apple", "banana", "pear")

str_detect(x, "e")
```

因为在数学意义上`F`为0,`T`为1，所以我们可以使用求和和求均值函数等，它们有时候可以发挥巨大用处。

```{r}
sum(str_detect(words, "^t"))
mean(str_detect(words, "[aeiou]$"))
```

**当逻辑条件非常复杂时，相对于创建单个正则表达式，使用逻辑运算符进行调用组合会更容易**。

例如下面可以找不包含元音字母的所有单词：

```{r}
no_vowel_1 = !str_detect(words, "[aeiou]")

no_vowel_2 = str_detect(words, "^[^aeiou]+$")

identical(no_vowel_1, no_vowel_2)
```

两种方法结果一致，但第一种更容易理解。

`str_detect`一种常见用法是选取匹配某种模式的元素，然后取子集，也可以使用`str_subset()`包装函数完全两步操作：

```{r}
words[str_detect(words, "x$")]

str_subset(words, "x$")
```

字符串通常是数据框的一列，我们可以联合`filter()`操作：

```{r}
df = tibble(
    word = words,
    i = seq_along(words)
)

df %>% 
    filter(str_detect(words, "x$"))
```

`str_detect()`函数的变体`str_count()`返回字符串中匹配的数量：

```{r}
str_count(x, "a")
```

`str_count()`完全可以和`mutate()`联合使用：

```{r}
df %>% 
    mutate(
        vowels = str_count(word, "[aeiou]"),
        consonants = str_count(word, "[^aeiou]")
    )
```

注意，匹配的模式不会重叠，比如`abababa`中`aba`只会匹配2次而不是3次：

```{r}
str_count("abababa", "aba")

str_view_all("abababa", "aba")
```

`str_view_all()`用于全部匹配。

### 提取匹配内容

我们可以使用`str_extract()`函数来提取匹配的实际文本。这里使用维基百科的Harvard sentences作为复杂的示例。

```{r}
length(sentences)

head(sentences)
```

假如现在我们想找出包含一种颜色的所有句子。我们先创建颜色名称向量，然后转换为正则表达式：

```{r}
colors = c(
    "red", "orange", "yellow", "green", "blue", "purple"
)

color_match = str_c(colors, collapse = "|")

color_match
```

现在我们选取出包含一种颜色的句子，然后再提取出颜色：

```{r}
has_color = str_subset(sentences, color_match)

matches = str_extract(has_color, color_match)

head(matches)
```

**注意，`str_extract()`只提取第一个匹配**。我们可以选取多余一种匹配的所有句子，这样我们更容易看到所有的匹配。

```{r}
more = sentences[str_count(sentences, color_match) > 1]
str_view_all(more, color_match)

str_extract(more, color_match)
```

**这是`stringr`函数的一种通用模式，单个匹配可以使用更简单的数据结构，想要得到所有的匹配，使用`str_extract_all()`函数，它会返回一个列表**。

```{r}
str_extract_all(more, color_match)
```

如果设置了`simplify = TRUE`，那么结果会是一个矩阵，其中短的匹配会和最长的匹配有一样的长度。

```{r}
str_extract_all(more, color_match, simplify = TRUE)
```

```{r}
x = c("a", "a b", "a b c")
str_extract_all(x, "[a-z]", simplify = TRUE)
```

### 分组匹配

括号在正则表达式中科院阐明优先级，还能对正则表达式进行分组，分组可以在匹配时回溯引用。我们因而可以用括号来提取复杂匹配的各个部分。

举例说明：加入我们想从句子中提取名词，我们可以先进行一种启发式实验，找出a或the后面的所有单词。使用正则表达式定义“单词”概念有点难度，我们使用一种简单的近似——至少有1个非空格字符的字符序列。

```{r}
noun = "(a|the) ([^ ]+)"

has_noun = sentences %>% 
    str_subset(noun) %>% 
    head(10)

has_noun %>% 
    str_extract(noun)
```

**`str_extract()`函数给出完整匹配，`str_match()`函数给出每个独立分组**。后面函数返回的不是字符向量而是矩阵：其中一列是完整匹配，后面的列是每个分组的匹配：

```{r}
has_noun %>% 
    str_match(noun)
```

>这种启发式名词检测的效果并不好，它找出了一些形容词，比如`smooth`和`parked`。

**如果数据保存在tibble中，使用`extract()`会更容易，该函数工作方式与`str_match()`函数类似，只需要为每个分组提供名词以作为结果的新列**。

```{r}
tibble(sentences = sentences) %>% 
    tidyr::extract(
        sentences, c("article", "noun"), "(a|the) ([^ ]+)",
        remove = FALSE
    )
```

同`str_extract()`函数一样，如果要找出所有的匹配，需要使用`str_match_all()`函数。


### 替换匹配内容

### 拆分

## 其他类型模式

## 正则表达式其他应用

## stringi

## 线程信息

```{r}
sessionInfo()
```

