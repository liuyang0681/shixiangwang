---
title: "stringr——处理字符串"
author: 王诗翔
date: 2018-09-17
slug: "stringr-operation"
categories: 
    - R
tags:
    - stringr
    - 字符串处理
---

<script src="/rmarkdown-libs/htmlwidgets/htmlwidgets.js"></script>
<link href="/rmarkdown-libs/str_view/str_view.css" rel="stylesheet" />
<script src="/rmarkdown-libs/str_view-binding/str_view.js"></script>


<p>导入包：</p>
<pre class="r"><code>library(tidyverse)
#&gt; ─ Attaching packages ───────────────────────────────────── tidyverse 1.2.1 ─
#&gt; ✔ ggplot2 3.0.0     ✔ purrr   0.2.5
#&gt; ✔ tibble  1.4.2     ✔ dplyr   0.7.6
#&gt; ✔ tidyr   0.8.1     ✔ stringr 1.3.1
#&gt; ✔ readr   1.1.1     ✔ forcats 0.3.0
#&gt; ─ Conflicts ─────────────────────────────────────── tidyverse_conflicts() ─
#&gt; ✖ dplyr::filter() masks stats::filter()
#&gt; ✖ dplyr::lag()    masks stats::lag()
library(stringr)</code></pre>
<pre class="r"><code>x = c(&quot;\&quot;&quot;, &quot;\\&quot;)</code></pre>
<p>显示字符串原始内容：</p>
<pre class="r"><code>writeLines(x)
#&gt; &quot;
#&gt; \</code></pre>
<div class="section level3">
<h3>字符串长度</h3>
<pre class="r"><code>str_length(c(&quot;a&quot;, &quot;R for data science&quot;, NA))
#&gt; [1]  1 18 NA</code></pre>
</div>
<div class="section level3">
<h3>字符串组合</h3>
<p>组合两个或多个：</p>
<pre class="r"><code>str_c(&quot;x&quot;, &quot;y&quot;)
#&gt; [1] &quot;xy&quot;
str_c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;)
#&gt; [1] &quot;xyz&quot;</code></pre>
<p>控制分隔：</p>
<pre class="r"><code>str_c(&quot;x&quot;, &quot;y&quot;, sep = &quot;,&quot;)
#&gt; [1] &quot;x,y&quot;</code></pre>
<p>缺失值是可以传染的，我们可以将<code>NA</code>输出为<code>&quot;NA&quot;</code>：</p>
<pre class="r"><code>x = c(&quot;abc&quot;, NA)
str_c(&quot;|-&quot;, x, &quot;-|&quot;)
#&gt; [1] &quot;|-abc-|&quot; NA
str_c(&quot;|-&quot;, str_replace_na(x), &quot;-|&quot;)
#&gt; [1] &quot;|-abc-|&quot; &quot;|-NA-|&quot;</code></pre>
<p>组合函数是向量化的：</p>
<pre class="r"><code>str_c(&quot;prefix-&quot;, c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), &quot;-suffix&quot;)
#&gt; [1] &quot;prefix-a-suffix&quot; &quot;prefix-b-suffix&quot; &quot;prefix-c-suffix&quot;</code></pre>
<p>将字符向量合并为字符串：</p>
<pre class="r"><code>str_c(c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;), collapse = &quot;, &quot;)
#&gt; [1] &quot;x, y, z&quot;</code></pre>
</div>
<div class="section level3">
<h3>字符串取子集</h3>
<pre class="r"><code>x = c(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Pear&quot;)
str_sub(x, 1, 3)
#&gt; [1] &quot;App&quot; &quot;Ban&quot; &quot;Pea&quot;</code></pre>
<p>负数表示从后到前：</p>
<pre class="r"><code>str_sub(x, -3, -1)
#&gt; [1] &quot;ple&quot; &quot;ana&quot; &quot;ear&quot;</code></pre>
<p>注意如果字符串过短函数也会返回尽可能多的字符：</p>
<pre class="r"><code>str_sub(&quot;a&quot;, 1, 5)
#&gt; [1] &quot;a&quot;</code></pre>
<p>以赋值的形式修改字符串：</p>
<pre class="r"><code>str_sub(x, 1, 1) = str_to_lower(str_sub(x, 1, 1))
x
#&gt; [1] &quot;apple&quot;  &quot;banana&quot; &quot;pear&quot;</code></pre>
</div>
<div class="section level3">
<h3>区域设置</h3>
<p>字符串的使用因国家地区不同可能有所不同。</p>
<pre class="r"><code>str_to_upper(c(&quot;i&quot;, &quot;l&quot;))
#&gt; [1] &quot;I&quot; &quot;L&quot;
str_to_upper(c(&quot;i&quot;, &quot;l&quot;), locale = &quot;tr&quot;)
#&gt; [1] &quot;İ&quot; &quot;L&quot;</code></pre>
<p>排序：</p>
<pre class="r"><code>x = c(&quot;apple&quot;, &quot;eggplant&quot;, &quot;banana&quot;)

str_sort(x, locale = &quot;en&quot;)
#&gt; [1] &quot;apple&quot;    &quot;banana&quot;   &quot;eggplant&quot;

str_sort(x, locale = &quot;haw&quot;)
#&gt; [1] &quot;apple&quot;    &quot;eggplant&quot; &quot;banana&quot;</code></pre>
</div>
<div class="section level2">
<h2>使用正则表达式</h2>
<p>我们可以通过<code>str_view()</code>和<code>str_view_all()</code>函数学习正则表达式。函数接受一个字符向量和一个正则表达式。</p>
<div class="section level3">
<h3>基础匹配</h3>
<p>精确匹配字符串：</p>
<pre class="r"><code>x = c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;)
str_view(x, &quot;an&quot;)</code></pre>
<div id="htmlwidget-1" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-1">{"x":{"html":"<ul>\n  <li>apple<\/li>\n  <li>b<span class='match'>an<\/span>ana<\/li>\n  <li>pear<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<p>另一个复杂的模式是使用<code>.</code>，它可以匹配除换行符外的任意字符：</p>
<pre class="r"><code>str_view(x, &quot;.a.&quot;)</code></pre>
<div id="htmlwidget-2" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-2">{"x":{"html":"<ul>\n  <li>apple<\/li>\n  <li><span class='match'>ban<\/span>ana<\/li>\n  <li>p<span class='match'>ear<\/span><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
</div>
<div class="section level3">
<h3>锚点</h3>
<ul>
<li><code>^</code>从字符串开头进行匹配</li>
<li><code>$</code>从字符串末尾进行匹配</li>
</ul>
<pre class="r"><code>str_view(x, &quot;^a&quot;)</code></pre>
<div id="htmlwidget-3" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-3">{"x":{"html":"<ul>\n  <li><span class='match'>a<\/span>pple<\/li>\n  <li>banana<\/li>\n  <li>pear<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<pre class="r"><code>str_view(x, &quot;a$&quot;)</code></pre>
<div id="htmlwidget-4" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-4">{"x":{"html":"<ul>\n  <li>apple<\/li>\n  <li>banan<span class='match'>a<\/span><\/li>\n  <li>pear<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
</div>
<div class="section level3">
<h3>字符串类与字符选项</h3>
<p>除了<code>.</code>，还有4种常见的字符类：</p>
<ul>
<li><code>\d</code>匹配任意数字</li>
<li><code>\s</code>匹配任意空白符</li>
<li><code>[abc]</code>匹配a、b或c</li>
<li><code>[^abc]</code>匹配除a、b、c之外的任意字符</li>
</ul>
<p>因为要对<code>\</code>转义，在R中使用正则需要<code>\\s</code>来匹配空白符，其他也一样。</p>
<p><code>|</code>可以获取可选模式，比如<code>abc|xyz</code>匹配<code>abc</code>或<code>xyz</code>，该操作符的优先级很低。</p>
<pre class="r"><code>str_view(c(&quot;grey&quot;, &quot;gray&quot;), &quot;gr(e|a)y&quot;)</code></pre>
<div id="htmlwidget-5" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-5">{"x":{"html":"<ul>\n  <li><span class='match'>grey<\/span><\/li>\n  <li><span class='match'>gray<\/span><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
</div>
<div class="section level3">
<h3>重复</h3>
<p>该操作用来控制某个模式能够匹配多少次：</p>
<ul>
<li><code>?</code>- 0次或一次</li>
<li><code>+</code>- 1次或多次</li>
<li><code>*</code>- 0次或多次</li>
</ul>
<pre class="r"><code>x = &quot;1888 is the longest year in Roman numerals: MDCCCLXXXVIII&quot;

str_view(x, &quot;CC?&quot;)</code></pre>
<div id="htmlwidget-6" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-6">{"x":{"html":"<ul>\n  <li>1888 is the longest year in Roman numerals: MD<span class='match'>CC<\/span>CLXXXVIII<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<pre class="r"><code>
str_view(x ,&quot;CC+&quot;)</code></pre>
<div id="htmlwidget-7" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-7">{"x":{"html":"<ul>\n  <li>1888 is the longest year in Roman numerals: MD<span class='match'>CCC<\/span>LXXXVIII<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<p>精确匹配次数：</p>
<ul>
<li><code>{n}</code>- 匹配n次</li>
<li><code>{n,}</code>- 匹配n次或更多次</li>
<li><code>{,m}</code>- 最多匹配m次</li>
<li><code>{n, m}</code>- 匹配n到m次</li>
</ul>
<pre class="r"><code>str_view(x, &quot;C{2}&quot;)</code></pre>
<div id="htmlwidget-8" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-8">{"x":{"html":"<ul>\n  <li>1888 is the longest year in Roman numerals: MD<span class='match'>CC<\/span>CLXXXVIII<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<pre class="r"><code>
str_view(x, &quot;C{2,}&quot;)</code></pre>
<div id="htmlwidget-9" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-9">{"x":{"html":"<ul>\n  <li>1888 is the longest year in Roman numerals: MD<span class='match'>CCC<\/span>LXXXVIII<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<pre class="r"><code>
str_view(x, &quot;C{2,3}&quot;)</code></pre>
<div id="htmlwidget-10" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-10">{"x":{"html":"<ul>\n  <li>1888 is the longest year in Roman numerals: MD<span class='match'>CCC<\/span>LXXXVIII<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<blockquote>
<p>默认的匹配方式是贪婪的，正则表达式会匹配尽量长的字符串，在后面添加<code>?</code>可以将匹配方式更改为懒惰的，即匹配尽量短的字符串。</p>
</blockquote>
<pre class="r"><code>str_view(x, &quot;C{2,3}?&quot;)</code></pre>
<div id="htmlwidget-11" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-11">{"x":{"html":"<ul>\n  <li>1888 is the longest year in Roman numerals: MD<span class='match'>CC<\/span>CLXXXVIII<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<pre class="r"><code>
str_view(x, &quot;C[LX]+?&quot;)</code></pre>
<div id="htmlwidget-12" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-12">{"x":{"html":"<ul>\n  <li>1888 is the longest year in Roman numerals: MDCC<span class='match'>CL<\/span>XXXVIII<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
</div>
<div class="section level3">
<h3>分组与回溯引用</h3>
<p>括号除了可以消除复杂表达式的歧义，还可以定义分组，我们可以通过<strong>回溯引用</strong>（如<code>\1</code>,<code>\2</code>等）来引用这些分组。</p>
<pre class="r"><code>str_view(fruit, &quot;(..)\\1&quot;, match = TRUE)</code></pre>
<div id="htmlwidget-13" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-13">{"x":{"html":"<ul>\n  <li>b<span class='match'>anan<\/span>a<\/li>\n  <li><span class='match'>coco<\/span>nut<\/li>\n  <li><span class='match'>cucu<\/span>mber<\/li>\n  <li><span class='match'>juju<\/span>be<\/li>\n  <li><span class='match'>papa<\/span>ya<\/li>\n  <li>s<span class='match'>alal<\/span> berry<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
</div>
</div>
<div class="section level2">
<h2>工具</h2>
<p>学习stringr多种函数，可以：</p>
<ul>
<li>确定与某种模式相匹配的字符串</li>
<li>找出匹配的位置</li>
<li>提取出匹配的内容</li>
<li>使用新值替换匹配内容</li>
<li>基于匹配拆分字符串</li>
</ul>
<div class="section level3">
<h3>匹配检测</h3>
<p>要想知道一个字符向量能否匹配一种模式，可以使用<code>str_detect()</code>：</p>
<pre class="r"><code>x = c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;)

str_detect(x, &quot;e&quot;)
#&gt; [1]  TRUE FALSE  TRUE</code></pre>
<p>因为在数学意义上<code>F</code>为0,<code>T</code>为1，所以我们可以使用求和和求均值函数等，它们有时候可以发挥巨大用处。</p>
<pre class="r"><code>sum(str_detect(words, &quot;^t&quot;))
#&gt; [1] 65
mean(str_detect(words, &quot;[aeiou]$&quot;))
#&gt; [1] 0.277</code></pre>
<p><strong>当逻辑条件非常复杂时，相对于创建单个正则表达式，使用逻辑运算符进行调用组合会更容易</strong>。</p>
<p>例如下面可以找不包含元音字母的所有单词：</p>
<pre class="r"><code>no_vowel_1 = !str_detect(words, &quot;[aeiou]&quot;)

no_vowel_2 = str_detect(words, &quot;^[^aeiou]+$&quot;)

identical(no_vowel_1, no_vowel_2)
#&gt; [1] TRUE</code></pre>
<p>两种方法结果一致，但第一种更容易理解。</p>
<p><code>str_detect</code>一种常见用法是选取匹配某种模式的元素，然后取子集，也可以使用<code>str_subset()</code>包装函数完全两步操作：</p>
<pre class="r"><code>words[str_detect(words, &quot;x$&quot;)]
#&gt; [1] &quot;box&quot; &quot;sex&quot; &quot;six&quot; &quot;tax&quot;

str_subset(words, &quot;x$&quot;)
#&gt; [1] &quot;box&quot; &quot;sex&quot; &quot;six&quot; &quot;tax&quot;</code></pre>
<p>字符串通常是数据框的一列，我们可以联合<code>filter()</code>操作：</p>
<pre class="r"><code>df = tibble(
    word = words,
    i = seq_along(words)
)

df %&gt;% 
    filter(str_detect(words, &quot;x$&quot;))
#&gt; # A tibble: 4 x 2
#&gt;   word      i
#&gt;   &lt;chr&gt; &lt;int&gt;
#&gt; 1 box     108
#&gt; 2 sex     747
#&gt; 3 six     772
#&gt; 4 tax     841</code></pre>
<p><code>str_detect()</code>函数的变体<code>str_count()</code>返回字符串中匹配的数量：</p>
<pre class="r"><code>str_count(x, &quot;a&quot;)
#&gt; [1] 1 3 1</code></pre>
<p><code>str_count()</code>完全可以和<code>mutate()</code>联合使用：</p>
<pre class="r"><code>df %&gt;% 
    mutate(
        vowels = str_count(word, &quot;[aeiou]&quot;),
        consonants = str_count(word, &quot;[^aeiou]&quot;)
    )
#&gt; # A tibble: 980 x 4
#&gt;    word         i vowels consonants
#&gt;    &lt;chr&gt;    &lt;int&gt;  &lt;int&gt;      &lt;int&gt;
#&gt;  1 a            1      1          0
#&gt;  2 able         2      2          2
#&gt;  3 about        3      3          2
#&gt;  4 absolute     4      4          4
#&gt;  5 accept       5      2          4
#&gt;  6 account      6      3          4
#&gt;  7 achieve      7      4          3
#&gt;  8 across       8      2          4
#&gt;  9 act          9      1          2
#&gt; 10 active      10      3          3
#&gt; # ... with 970 more rows</code></pre>
<p>注意，匹配的模式不会重叠，比如<code>abababa</code>中<code>aba</code>只会匹配2次而不是3次：</p>
<pre class="r"><code>str_count(&quot;abababa&quot;, &quot;aba&quot;)
#&gt; [1] 2

str_view_all(&quot;abababa&quot;, &quot;aba&quot;)</code></pre>
<div id="htmlwidget-14" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-14">{"x":{"html":"<ul>\n  <li><span class='match'>aba<\/span>b<span class='match'>aba<\/span><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<p><code>str_view_all()</code>用于全部匹配。</p>
</div>
<div class="section level3">
<h3>提取匹配内容</h3>
<p>我们可以使用<code>str_extract()</code>函数来提取匹配的实际文本。这里使用维基百科的Harvard sentences作为复杂的示例。</p>
<pre class="r"><code>length(sentences)
#&gt; [1] 720

head(sentences)
#&gt; [1] &quot;The birch canoe slid on the smooth planks.&quot; 
#&gt; [2] &quot;Glue the sheet to the dark blue background.&quot;
#&gt; [3] &quot;It&#39;s easy to tell the depth of a well.&quot;     
#&gt; [4] &quot;These days a chicken leg is a rare dish.&quot;   
#&gt; [5] &quot;Rice is often served in round bowls.&quot;       
#&gt; [6] &quot;The juice of lemons makes fine punch.&quot;</code></pre>
<p>假如现在我们想找出包含一种颜色的所有句子。我们先创建颜色名称向量，然后转换为正则表达式：</p>
<pre class="r"><code>colors = c(
    &quot;red&quot;, &quot;orange&quot;, &quot;yellow&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;purple&quot;
)

color_match = str_c(colors, collapse = &quot;|&quot;)

color_match
#&gt; [1] &quot;red|orange|yellow|green|blue|purple&quot;</code></pre>
<p>现在我们选取出包含一种颜色的句子，然后再提取出颜色：</p>
<pre class="r"><code>has_color = str_subset(sentences, color_match)

matches = str_extract(has_color, color_match)

head(matches)
#&gt; [1] &quot;blue&quot; &quot;blue&quot; &quot;red&quot;  &quot;red&quot;  &quot;red&quot;  &quot;blue&quot;</code></pre>
<p><strong>注意，<code>str_extract()</code>只提取第一个匹配</strong>。我们可以选取多余一种匹配的所有句子，这样我们更容易看到所有的匹配。</p>
<pre class="r"><code>more = sentences[str_count(sentences, color_match) &gt; 1]
str_view_all(more, color_match)</code></pre>
<div id="htmlwidget-15" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-15">{"x":{"html":"<ul>\n  <li>It is hard to erase <span class='match'>blue<\/span> or <span class='match'>red<\/span> ink.<\/li>\n  <li>The <span class='match'>green<\/span> light in the brown box flicke<span class='match'>red<\/span>.<\/li>\n  <li>The sky in the west is tinged with <span class='match'>orange<\/span> <span class='match'>red<\/span>.<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<pre class="r"><code>
str_extract(more, color_match)
#&gt; [1] &quot;blue&quot;   &quot;green&quot;  &quot;orange&quot;</code></pre>
<p><strong>这是<code>stringr</code>函数的一种通用模式，单个匹配可以使用更简单的数据结构，想要得到所有的匹配，使用<code>str_extract_all()</code>函数，它会返回一个列表</strong>。</p>
<pre class="r"><code>str_extract_all(more, color_match)
#&gt; [[1]]
#&gt; [1] &quot;blue&quot; &quot;red&quot; 
#&gt; 
#&gt; [[2]]
#&gt; [1] &quot;green&quot; &quot;red&quot;  
#&gt; 
#&gt; [[3]]
#&gt; [1] &quot;orange&quot; &quot;red&quot;</code></pre>
<p>如果设置了<code>simplify = TRUE</code>，那么结果会是一个矩阵，其中短的匹配会和最长的匹配有一样的长度。</p>
<pre class="r"><code>str_extract_all(more, color_match, simplify = TRUE)
#&gt;      [,1]     [,2] 
#&gt; [1,] &quot;blue&quot;   &quot;red&quot;
#&gt; [2,] &quot;green&quot;  &quot;red&quot;
#&gt; [3,] &quot;orange&quot; &quot;red&quot;</code></pre>
<pre class="r"><code>x = c(&quot;a&quot;, &quot;a b&quot;, &quot;a b c&quot;)
str_extract_all(x, &quot;[a-z]&quot;, simplify = TRUE)
#&gt;      [,1] [,2] [,3]
#&gt; [1,] &quot;a&quot;  &quot;&quot;   &quot;&quot;  
#&gt; [2,] &quot;a&quot;  &quot;b&quot;  &quot;&quot;  
#&gt; [3,] &quot;a&quot;  &quot;b&quot;  &quot;c&quot;</code></pre>
</div>
<div class="section level3">
<h3>分组匹配</h3>
<p>括号在正则表达式中科院阐明优先级，还能对正则表达式进行分组，分组可以在匹配时回溯引用。我们因而可以用括号来提取复杂匹配的各个部分。</p>
<p>举例说明：加入我们想从句子中提取名词，我们可以先进行一种启发式实验，找出a或the后面的所有单词。使用正则表达式定义“单词”概念有点难度，我们使用一种简单的近似——至少有1个非空格字符的字符序列。</p>
<pre class="r"><code>noun = &quot;(a|the) ([^ ]+)&quot;

has_noun = sentences %&gt;% 
    str_subset(noun) %&gt;% 
    head(10)

has_noun %&gt;% 
    str_extract(noun)
#&gt;  [1] &quot;the smooth&quot; &quot;the sheet&quot;  &quot;the depth&quot;  &quot;a chicken&quot;  &quot;the parked&quot;
#&gt;  [6] &quot;the sun&quot;    &quot;the huge&quot;   &quot;the ball&quot;   &quot;the woman&quot;  &quot;a helps&quot;</code></pre>
<p><strong><code>str_extract()</code>函数给出完整匹配，<code>str_match()</code>函数给出每个独立分组</strong>。后面函数返回的不是字符向量而是矩阵：其中一列是完整匹配，后面的列是每个分组的匹配：</p>
<pre class="r"><code>has_noun %&gt;% 
    str_match(noun)
#&gt;       [,1]         [,2]  [,3]     
#&gt;  [1,] &quot;the smooth&quot; &quot;the&quot; &quot;smooth&quot; 
#&gt;  [2,] &quot;the sheet&quot;  &quot;the&quot; &quot;sheet&quot;  
#&gt;  [3,] &quot;the depth&quot;  &quot;the&quot; &quot;depth&quot;  
#&gt;  [4,] &quot;a chicken&quot;  &quot;a&quot;   &quot;chicken&quot;
#&gt;  [5,] &quot;the parked&quot; &quot;the&quot; &quot;parked&quot; 
#&gt;  [6,] &quot;the sun&quot;    &quot;the&quot; &quot;sun&quot;    
#&gt;  [7,] &quot;the huge&quot;   &quot;the&quot; &quot;huge&quot;   
#&gt;  [8,] &quot;the ball&quot;   &quot;the&quot; &quot;ball&quot;   
#&gt;  [9,] &quot;the woman&quot;  &quot;the&quot; &quot;woman&quot;  
#&gt; [10,] &quot;a helps&quot;    &quot;a&quot;   &quot;helps&quot;</code></pre>
<blockquote>
<p>这种启发式名词检测的效果并不好，它找出了一些形容词，比如<code>smooth</code>和<code>parked</code>。</p>
</blockquote>
<p><strong>如果数据保存在tibble中，使用<code>extract()</code>会更容易，该函数工作方式与<code>str_match()</code>函数类似，只需要为每个分组提供名词以作为结果的新列</strong>。</p>
<pre class="r"><code>tibble(sentences = sentences) %&gt;% 
    tidyr::extract(
        sentences, c(&quot;article&quot;, &quot;noun&quot;), &quot;(a|the) ([^ ]+)&quot;,
        remove = FALSE
    )
#&gt; # A tibble: 720 x 3
#&gt;    sentences                                   article noun   
#&gt;    &lt;chr&gt;                                       &lt;chr&gt;   &lt;chr&gt;  
#&gt;  1 The birch canoe slid on the smooth planks.  the     smooth 
#&gt;  2 Glue the sheet to the dark blue background. the     sheet  
#&gt;  3 It&#39;s easy to tell the depth of a well.      the     depth  
#&gt;  4 These days a chicken leg is a rare dish.    a       chicken
#&gt;  5 Rice is often served in round bowls.        &lt;NA&gt;    &lt;NA&gt;   
#&gt;  6 The juice of lemons makes fine punch.       &lt;NA&gt;    &lt;NA&gt;   
#&gt;  7 The box was thrown beside the parked truck. the     parked 
#&gt;  8 The hogs were fed chopped corn and garbage. &lt;NA&gt;    &lt;NA&gt;   
#&gt;  9 Four hours of steady work faced us.         &lt;NA&gt;    &lt;NA&gt;   
#&gt; 10 Large size in stockings is hard to sell.    &lt;NA&gt;    &lt;NA&gt;   
#&gt; # ... with 710 more rows</code></pre>
<p>同<code>str_extract()</code>函数一样，如果要找出所有的匹配，需要使用<code>str_match_all()</code>函数。</p>
</div>
<div class="section level3">
<h3>替换匹配内容</h3>
</div>
<div class="section level3">
<h3>拆分</h3>
</div>
</div>
<div class="section level2">
<h2>其他类型模式</h2>
</div>
<div class="section level2">
<h2>正则表达式其他应用</h2>
</div>
<div id="stringi" class="section level2">
<h2>stringi</h2>
</div>
<div class="section level2">
<h2>线程信息</h2>
<pre class="r"><code>sessionInfo()
#&gt; R version 3.5.1 (2018-07-02)
#&gt; Platform: x86_64-apple-darwin15.6.0 (64-bit)
#&gt; Running under: macOS High Sierra 10.13.6
#&gt; 
#&gt; Matrix products: default
#&gt; BLAS: /Library/Frameworks/R.framework/Versions/3.5/Resources/lib/libRblas.0.dylib
#&gt; LAPACK: /Library/Frameworks/R.framework/Versions/3.5/Resources/lib/libRlapack.dylib
#&gt; 
#&gt; locale:
#&gt; [1] zh_CN.UTF-8/zh_CN.UTF-8/zh_CN.UTF-8/C/zh_CN.UTF-8/zh_CN.UTF-8
#&gt; 
#&gt; attached base packages:
#&gt; [1] stats     graphics  grDevices utils     datasets  methods   base     
#&gt; 
#&gt; other attached packages:
#&gt;  [1] bindrcpp_0.2.2  forcats_0.3.0   stringr_1.3.1   dplyr_0.7.6    
#&gt;  [5] purrr_0.2.5     readr_1.1.1     tidyr_0.8.1     tibble_1.4.2   
#&gt;  [9] ggplot2_3.0.0   tidyverse_1.2.1 pacman_0.4.6   
#&gt; 
#&gt; loaded via a namespace (and not attached):
#&gt;  [1] tidyselect_0.2.4    xfun_0.3            haven_1.1.2        
#&gt;  [4] lattice_0.20-35     colorspace_1.3-2    htmltools_0.3.6    
#&gt;  [7] yaml_2.2.0          utf8_1.1.4          rlang_0.2.2        
#&gt; [10] pillar_1.3.0        glue_1.3.0          withr_2.1.2        
#&gt; [13] modelr_0.1.2        readxl_1.1.0        bindr_0.1.1        
#&gt; [16] plyr_1.8.4          munsell_0.5.0       blogdown_0.8       
#&gt; [19] gtable_0.2.0        cellranger_1.1.0    rvest_0.3.2        
#&gt; [22] htmlwidgets_1.2     evaluate_0.11       knitr_1.20         
#&gt; [25] fansi_0.3.0         broom_0.5.0         Rcpp_0.12.18       
#&gt; [28] scales_1.0.0        backports_1.1.2     jsonlite_1.5       
#&gt; [31] hms_0.4.2           digest_0.6.16       stringi_1.2.4      
#&gt; [34] bookdown_0.7        grid_3.5.1          rprojroot_1.3-2    
#&gt; [37] cli_1.0.0           tools_3.5.1         magrittr_1.5       
#&gt; [40] lazyeval_0.2.1.9000 crayon_1.3.4        pkgconfig_2.0.2    
#&gt; [43] xml2_1.2.0          lubridate_1.7.4     assertthat_0.2.0   
#&gt; [46] rmarkdown_1.10      httr_1.3.1          rstudioapi_0.7     
#&gt; [49] R6_2.2.2            nlme_3.1-137        compiler_3.5.1</code></pre>
</div>
